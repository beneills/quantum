<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <meta name="description" content="API documentation for the Rust `float_cmp` crate.">
    <meta name="keywords" content="rust, rustlang, rust-lang, float_cmp">

    <title>float_cmp - Rust</title>

    <link rel="stylesheet" type="text/css" href="../rustdoc.css">
    <link rel="stylesheet" type="text/css" href="../main.css">
    

    
    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    

    <nav class="sidebar">
        
        <p class='location'></p><script>window.sidebarCurrent = {name: 'float_cmp', ty: 'mod', relpath: '../'};</script>
    </nav>

    <nav class="sub">
        <form class="search-form js-only">
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Click or press ‘S’ to search, ‘?’ for more options…"
                       type="search">
            </div>
        </form>
    </nav>

    <section id='main' class="content mod">
<h1 class='fqn'><span class='in-band'>Crate <a class='mod' href=''>float_cmp</a></span><span class='out-of-band'><span id='render-detail'>
                   <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">
                       [<span class='inner'>&#x2212;</span>]
                   </a>
               </span><a id='src-0' class='srclink' href='../src/float_cmp/lib.rs.html#4-496' title='goto source code'>[src]</a></span></h1>
<div class='docblock'><p>float-cmp defines traits for approximate comparison of floating point types which have fallen
away from exact equality due to rounding and inaccuracies within the floating point unit of your
computer&#39;s processor. Implementations of these traits are provided for <code>f32</code> and <code>f64</code> types.</p>

<p>Two methods of comparison are provided. The first, <code>ApproxEqUlps</code> and <code>ApproxOrdUlps</code>, consider
two comparands equal if the number of representable floating point numbers between them is
below a specified bound. This works well in most cases.</p>

<p>The second method of comparison, <code>ApproxEqRatio</code>, considers two comparands equal if the ratio of
the difference between them to the larger is below some specified bound.  This handles many of
the cases that the former type of comparison doesn&#39;t handle well.</p>

<p>To help choose which comparison method to use, and to learn many suprising facts and oddities
about floating point numbers, please refer to the following excellent website:
<a href="https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/">https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/</a></p>

<p>The trait <code>Ulps</code> is also defined as a prerequisite for <code>ApproxEqUlps</code> and <code>ApproxOrdUlps</code>.</p>

<p>Floating point operations must round answers to the nearest representable number.  Multiple
operations may result in an answer different from what you expect.  In the following example,
the assert will fail, even though the printed output says &quot;0.45 == 0.45&quot;:</p>

<pre><code class="language-should_fail">  let a = 0.15_f32 + 0.15_f32 + 0.15_f32;
  let b = 0.1_f32 + 0.1_f32 + 0.25_f32;
  println!(&quot;{} == {}&quot;, a, b);
  assert!(a==b)  // Fails, because they are not exactly equal
</code></pre>

<p>This fails due to rounding and inaccuracies within the floating point unit of your processor.
With <code>ApproxEqUlps</code>, we can get the answer we intend:</p>

<pre class='rust rust-example-rendered'>
  <span class='kw'>let</span> <span class='ident'>a</span> <span class='op'>=</span> <span class='number'>0.15_f32</span> <span class='op'>+</span> <span class='number'>0.15_f32</span> <span class='op'>+</span> <span class='number'>0.15_f32</span>;
  <span class='kw'>let</span> <span class='ident'>b</span> <span class='op'>=</span> <span class='number'>0.1_f32</span> <span class='op'>+</span> <span class='number'>0.1_f32</span> <span class='op'>+</span> <span class='number'>0.25_f32</span>;
  <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{} == {}&quot;</span>, <span class='ident'>a</span>, <span class='ident'>b</span>);
  <span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>a</span>.<span class='ident'>approx_eq_ulps</span>(<span class='kw-2'>&amp;</span><span class='ident'>b</span>,<span class='number'>2</span>)) <span class='comment'>// They are equal, within 2 ulps</span></pre>

<p>We use the term ULP (units of least precision, or units in the last place) to mean the
difference between two adjacent floating point representations (adjacent meaning that there is
no floating point number between them).  The size of an ULP (measured as a float) varies
depending on the exponents of the floating point numbers in question, but this is quite useful,
for it is the non-variation of a fixed epsilon (e.g. 0.0000001) which causes epsilon-based
comparisons to so often fail with more extreme floating point values.</p>

<p>Fixed epsilon systems of comparison tend to work well only on numbers within certain ranges.
It may seem reasonable to expect numbers that differ by less than 0.000001 to be equal, but
this does not always work well (consider comparing -0.0000000028 to +0.00000097).</p>
</div><h2 id='traits' class='section-header'><a href="#traits">Traits</a></h2>
<table>
                       <tr class=' module-item'>
                           <td><a class='trait' href='trait.ApproxEqRatio.html'
                                  title='float_cmp::ApproxEqRatio'>ApproxEqRatio</a></td>
                           <td class='docblock short'>
                                <p>ApproxEqRatio is a trait for approximate equality comparisons bounding the ratio
of the difference to the larger.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='trait' href='trait.ApproxEqUlps.html'
                                  title='float_cmp::ApproxEqUlps'>ApproxEqUlps</a></td>
                           <td class='docblock short'>
                                <p>ApproxEqUlps is a trait for approximate equality comparisons, and is defined only
for floating point types.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='trait' href='trait.ApproxOrdUlps.html'
                                  title='float_cmp::ApproxOrdUlps'>ApproxOrdUlps</a></td>
                           <td class='docblock short'>
                                <p>ApproxOrdUlps is for sorting floating point values where approximate equality
is considered equal.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='trait' href='trait.Ulps.html'
                                  title='float_cmp::Ulps'>Ulps</a></td>
                           <td class='docblock short'>
                                <p>A trait for floating point numbers which computes the number of representable
values or ULPs (Units of Least Precision) that separate the two given values.</p>
                           </td>
                       </tr></table></section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <aside id="help" class="hidden">
        <div>
            <h1 class="hidden">Help</h1>

            <div class="shortcuts">
                <h2>Keyboard Shortcuts</h2>

                <dl>
                    <dt>?</dt>
                    <dd>Show this help dialog</dd>
                    <dt>S</dt>
                    <dd>Focus the search field</dd>
                    <dt>&larrb;</dt>
                    <dd>Move up in search results</dd>
                    <dt>&rarrb;</dt>
                    <dd>Move down in search results</dd>
                    <dt>&#9166;</dt>
                    <dd>Go to active search result</dd>
                    <dt>+</dt>
                    <dd>Collapse/expand all sections</dd>
                </dl>
            </div>

            <div class="infos">
                <h2>Search Tricks</h2>

                <p>
                    Prefix searches with a type followed by a colon (e.g.
                    <code>fn:</code>) to restrict the search to a given type.
                </p>

                <p>
                    Accepted types are: <code>fn</code>, <code>mod</code>,
                    <code>struct</code>, <code>enum</code>,
                    <code>trait</code>, <code>type</code>, <code>macro</code>,
                    and <code>const</code>.
                </p>

                <p>
                    Search functions by type signature (e.g.
                    <code>vec -> usize</code> or <code>* -> vec</code>)
                </p>
            </div>
        </div>
    </aside>

    

    <script>
        window.rootPath = "../";
        window.currentCrate = "float_cmp";
        window.playgroundUrl = "";
    </script>
    <script src="../jquery.js"></script>
    <script src="../main.js"></script>
    
    <script defer src="../search-index.js"></script>
</body>
</html>